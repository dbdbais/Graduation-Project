<!DOCTYPE html>
<html lang="en">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <link rel="stylesheet" href="load.css">
  <link rel="stylesheet" href="skeleton.css">

    <style>

.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 9999;
}
section {
    flex-direction : row;
    padding-top: 80px; /* Adjust this value based on your header's height */
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: calc(100vh - 150px); /* Adjust height for header and footer */
}

  @keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
.fade-in {
  animation: fadeIn 0.5s ease-in;
}
.center{
  text-align: center;
}
#box {
  display: flex;
  font-size : 30px;
  padding: 40px;
  flex-direction: column;
  width: 60%; /* Limit the maximum width of the table to 80% of the viewport */
  height: 70%; 
  border-radius: 20px;
  box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0));
  overflow: auto;
  opacity: 1;
  transition: opacity 0.5s ease-in-out;
}
#box h1 {
  margin: 20px 0; /* Add space above and below the h1 */
  font-size: 50px; /* Increase the font size */
  font-weight: bold; /* Make the text bold */
  color: #333; /* Change the text color to a darker shade */
}
#box p {
  margin: 10px 0; /* Add space above and below each paragraph */
  font-size: 30px; /* Increase the font size */
  line-height: 1.5; /* Adjust the line height for better readability */
  color: #666; /* Change the text color to a slightly darker shade */
}
#box img {
  margin: 0 auto;
  display: block;
  width: 80%;
  height: auto; /* Set height to auto for maintaining aspect ratio */
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Add a subtle shadow for the 3D effect */
  transition: transform 0.3s ease-in-out; /* Add a smooth transition effect */
}

#box img:hover {
  transform: scale(1.05); /* Scale the image slightly on hover for an interactive effect */
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Enhance the shadow on hover */
}
#box figcaption{
  margin-top: 5px;
  font-size: 20px;
  font-weight: bold;
  text-align: center;
}
strong{
  color: red;
}

    </style>
<script>
var count =0;
window.onload = function () {
  displayBox(0);
};

function displayBox(count){
  event.preventDefault();
  var box = document.getElementById("box");
  box.innerHTML="";
  if(count == 0){
    box.innerHTML = '<h1 class="center"> Simple Guide</h1><p>저희 졸업과제 제목은<strong>“멀티 모달을 활용한 텍스트 기반 스팸 필터링 모델 개발”</strong> 입니다. 먼저 저희 과제의 핵심 키워드인 “멀티모달”에 대해서 이해가 필수적이라 먼저 설명드리겠습니다. </p><p>여기서 <strong>모달리티 라는 것은 데이터의 형태, 유형을 의미</strong>합니다. 이 세상에는 하나의 데이터가 여러 가지 방식으로 표현될 수 있습니다. 예를 들어, 사람이라는 것을 표현할 때 그 사람의 행동, 목소리, 표정, 대화 등 여러가지 방법으로 표현할 수 있죠. 이런 것들을 전부 하나의 모달리티로 볼 수 있는거에요.</p><figure><img src="info/1.png"alt="Image Description"><figcaption>[그림-1] 모달리티설명</figcaption></figure><p>기존의 많은 모델이 하나의 유형에 대한 데이터만 처리하고 있습니다. 예를 들어, 저희 주제인 스팸 필터링의 경우에는 “텍스트”라는 단일 모달리티에 대한 처리만 하여 “이미지”라는 모달리티가 메일로 전송되는 경우 스팸 필터링의 역할을 제대로 수행하지 못한다는 단점이 있습니다.</p><p>그래서 저희는 멀티모달 딥러닝을 활용하여 텍스트뿐만 아니라, 이미지와 Chat-GPT와 같은 생성 도구로 만든 메일도 하나의 모달리티로보고 총 3가지 모달 <strong>이미지, 수집텍스트, 생성텍스트</strong>에 대한 처리가 가능하도록 스팸 필터링 모델을 구현하였습니다.</p><p>그래서 다시 간단하게 말씀드리면, 저희는 <strong>이미지랑 텍스트가 같이 들어 와도 잘 처리할 수 있다</strong>는 거예요.물론 생성이랑 텍스트가 같이 들어 와도 마찬가지겠죠.</p><p>자 긴설명을 했으니 저희 졸업 과제는 어떤 구조로 돌아가는지 그림으로 보여드릴게요!</p><figure><img src="info/2.png"alt="Image Description"><figcaption>[그림-2] 구조</figcaption></figure><p>이런 식으로 텍스트와 이미지가 같이 메일로 들어오는 경우 텍스트 따로, 이미지 따로, 텍스트 이미지 합쳐서 따로 총 3개의 모델에 넣고 과반수 투표로 결과를 예측하는 거죠. 이러면 더욱 신뢰도가 높아지겠죠? 여기까지가 대략적인 설명이고 다음 내용에서 저희가 어떤 부분들을 개선했는지 보여드릴게요!</p>';
  }
  else if(count == 1){
    box.innerHTML ='<h1 class="center">피처 분석 방법 및 분석 결과</h1><p>기본적으로 머신 러닝이란 것이 피처를 바탕으로 컴퓨터가 열심히 학습해서 결과를 예측하는 거죠. 여기서 가장 중요한 것이 <strong>어떤 피처를 잘 선정해야 정확도를 높일 수 있는지에요.</strong></p><p>그래서 저희는 총 16개의 feature 후보 중에 양상별로 가장 최적의 피처를 선정하기 위해서 열심히 분석했습니다.</p><p>아래 보이는 그림이 저희가 분석할 때 사용한 방법인데, 히스토그램을 이용해서 text와 image에서의 피처의 분포를 나타낸 거예요.보시면, 그래프가 겹치는 부분이 보이는데 이 겹치는 부분이 적을수록 모달리티별로 차이가 크다는 것이고, 저희는 <strong>겹치는 비율이 50% 미만인 feature만 선정</strong>해서 각 모달의 feature로 사용했습니다.</p><figure><img src="info/3.png"alt="Image Description"><figcaption>[그림-3] Histogram</figcaption></figure><p>최종적으로 선정된 피처는 아래 표와 같아요.</p><figure><img src="info/4.png"alt="Image Description"><figcaption>[그림-4] 선정된 Feature</figcaption></figure><p>이런 식으로 텍스트와 이미지가 같이 메일로 들어오는 경우 텍스트 따로, 이미지 따로, 텍스트 이미지 합쳐서 따로 총 3개의 모델에 넣고 과반수 투표로 결과를 예측하는 거죠. 이러면 더욱 신뢰도가 높아지겠죠? 여기까지가 대략적인 설명이고 다음 내용에서 저희가 어떤 부분들을 개선했는지 보여드릴게요!</p><p>보시면, 겹치는 비율을 표로 나타낸 것인데 spam과 ham label에서 동시에 겹치는 면적이 50% 미만인 피처들만 선정했고 혹시나 저희가 정한 기준이 올바르지 않을 수도 있다는 것을 검증하기 위해서 50% 이상의 피처들로도 테스트해 보았는데, 다행히 저희가 선정한 피처들로 하는 것이 훨씬 성능이 높게 나왔습니다.</p>';
  }
  else if (count == 2){
    box.innerHTML +='<h1 class="center">최종 결과 표, Confusion Matrix</h1><p>그래서 최종 결과가 어떻게 나왔는지 아래 표로 정리해서 보여드릴게요.</p><figure><img src="info/5.png"alt="Image Description"><figcaption>[그림-5] 최종 결과</figcaption></figure><p>위의 collect, image, create 단일 모델들을 보면, 각자 학습한 모달리티에 대한 성능은 전부 90%가 넘는걸 볼 수 있어요. 그런데, collect 모델을 예로 들어보면 collect에 대한 정확도는 높지만, 다른 모달리티 혹은 모달리티가 여러 개 들어오는 경우 정확도가 확 떨어지는 것이 보이죠? 저희는 이 문제를 밑에 create+image 그리고 collect+image를 통해서 해결했어요. collect+image와 create+image를 통합 모델이라고 부를게요. 통합모델의 성능을 보시면 모달리티가 함께 들어오면 정확도가 훨씬 개선된 것을 볼 수 있어요. 수치로만 따지면 <strong>20퍼센트 이상 성능향상</strong>이 된거죠.</p><p>그래서 위 5개 모델을 이용하여 앞서 설명해 드린 과반수 투표를 통해서 최종 모델을 구현하고, 성능을 높일 수 있었어요.</p><figure><img src="info/6.png"alt="Image Description"><figcaption>[그림-6] Confusion Matrix</figcaption></figure><p><strong>• Accuracy(정확도): 0.9414</strong></p><p><strong>• Recall(재현율): 0.9069</strong></p><p><strong>• Precision(정밀도): 0.9429</strong></p><p><strong>• Specificity(특이도): 0.9640</strong></p><p><strong>• F1 Score: 0.9246</strong></p><p>저희 모델의 최종 테스트 결과를 Confusion  matrix로 나타내어 보았습니다. 보시면 <strong>잘못 분류한 경우가 총 1,058개데이터 중, 62개</strong>에요. 즉 정확도가 94% 정도로 나온다는 거죠. 물론, 100퍼센트 정확도가 아니라 아쉽긴 하지만, 이건 데이터를 더욱 다양하게 수집하고, 개수를 늘리면 향상될 것으로 예상돼요. 하지만 시간상, 그리고 데이터 세트 부족으로 인해서 현재 결과가 나오게 되었습니다.</p>';
    
  }
  box.classList.remove("fade-in");
  void box.offsetWidth;
  box.classList.add("fade-in");
  box.scrollTop = 0;
}
  // JavaScript function to show the previous div
  function showPreviousDiv() {
    event.preventDefault();
      if (count==0) {
        alert("처음 페이지입니다.");
      }
      else{
        count -=1;
        displayBox(count);
      }
  }

  // JavaScript function to show the next div
  function showNextDiv() {
    event.preventDefault();
      if (count ==2) {
        alert("마지막 페이지입니다.");
      }
      else{
          count +=1;
          displayBox(count);
      }
  }

  // Function to find the currently visible div
  function getCurrentDiv() {
    var divElements = document.getElementsByTagName('div');
      for (var i = 0; i < divElements.length; i++) {
          if (divElements[i].style.display !== 'none') {
              return divElements[i];
          }
      }
      return null; // If no div is currently visible
  }
  function homePage(){
          event.preventDefault();
          showOverLay(); // Show the loading overlay
             setTimeout(function () {
                hideOverlay(); // Hide the loading overlay
                location.href = 'FirstPage.php'; // Redirect to the info page
            }, 500); // 1-second delay
        }
        function showOverLay(){
        var overlay = document.createElement("div");
        overlay.classList.add("overlay");
        var loadingContainer = document.createElement("div");
        loadingContainer.classList.add("loading-container");
        var loadingDiv = document.createElement("div");
        loadingDiv.classList.add("loading");
        var loadingText = document.createElement("div");
        loadingText.id = "loading-text";
        loadingText.textContent = "loading";
        loadingContainer.appendChild(loadingDiv);
        loadingContainer.appendChild(loadingText);
        overlay.appendChild(loadingContainer);
        document.body.appendChild(overlay);
    }
      function hideOverlay() {
        var overlay = document.querySelector(".overlay");
        if (overlay) {
            document.body.removeChild(overlay);
        }
    }
    function refresh(){
      event.preventDefault();
      showOverLay(); // Show the loading overlay
             setTimeout(function () {
                hideOverlay(); // Hide the loading overlay
                location.reload(); // Redirect to the info page
            }, 200); // 1-second delay
    }
</script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Learning</title>
</head>
<body>
  <header>
    <img src = "arrow.png" onclick="refresh()" id="arrow">
    <h1 class="stylish-header">Machine Learning</h1>
    <img src = "home.png" onclick="homePage()" id="hicon">
</header>
    <section>
      <img src = "left.png" onclick="showPreviousDiv()" id="iter">
   <div id="box"></div>
    <img src = "right.png" onclick="showNextDiv()" id="iter">
</section>
<footer>
    <h4> Copyright © 2023 Team_49 All rights reserved.</h4>
    </footer>
</body>
</html>